Effect Print: string -> unitEffect Read: unit -> stringEffect RandomInt: int -> intEffect RandomFloat: float -> float_ocaml_tophandler: τ₂ -> τ₂ = _ocaml_tophandler_var_1 (* = *): τ₃ -> τ₃ -> bool = =_var_2 (* < *): τ₄ -> τ₄ -> bool = <failwith: string -> τ₅ = failwithinfinity: float = infinityneg_infinity: float = neg_infinitynan: float = nan_var_7 (* ~- *): int -> int = ~-_var_8 (* + *): int -> int -> int = +_var_9 (* * *): int -> int -> int = *_var_10 (* - *): int -> int -> int = -mod: int -> int -> int = mod_var_12 (* ~-. *): float -> float = ~-._var_13 (* +. *): float -> float -> float = +._var_14 (* *. *): float -> float -> float = *._var_15 (* -. *): float -> float -> float = -._var_16 (* /. *): float -> float -> float = /._var_17 (* ** *): int -> int -> int = **_var_18 (* / *): int -> int -> int = /exp: float -> float = expexpm1: float -> float = expm1log: float -> float = loglog1p: float -> float = log1pcos: float -> float = cossin: float -> float = sintan: float -> float = tanacos: float -> float = acosasin: float -> float = asinatan: float -> float = atansqrt: float -> float = sqrtfloat_of_int: int -> float = float_of_intint_of_float: float -> int = int_of_float_var_32 (* ^ *): string -> string -> string = ^string_length: string -> int = string_lengthstring_of_float: float -> string = string_of_floatstring_of_int: int -> string = string_of_int| None | Some of τ₆ ;  Effect Dummy: unit -> intlet h9 = fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> fun (x) -> x y  x1 return fun (x) -> x x2 fun c -> handler {
 value_clause = (fun y ->  return fun (x) -> x let x = fun (x) -> x y in x);
effect_clauses = (fun (type a) (type b) (x : (a, b) effect) ->
             ((match x with | Dummy -> (fun (_ : unit) (l : int -> _ computation) -> return fun (x) -> x 3) | eff' -> fun arg k -> Call (eff', arg, k)) : a -> (b -> _ computation) -> _ computation)) } c in let h8 = fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> fun (x) -> x y  x1 return fun (x) -> x x2 fun c -> handler {
 value_clause = (fun y ->  return fun (x) -> x let x = fun (x) -> x y in x);
effect_clauses = (fun (type a) (type b) (x : (a, b) effect) ->
             ((match x with | Dummy -> (fun (_ : unit) (l : int -> _ computation) -> return fun (x) -> x fun (x1) -> fun (x2) -> fun (x) -> x x1 fun (x) -> x x2 h9 fun (x) -> x 3) | eff' -> fun arg k -> Call (eff', arg, k)) : a -> (b -> _ computation) -> _ computation)) } c in let h7 = fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> fun (x) -> x y  x1 return fun (x) -> x x2 fun c -> handler {
 value_clause = (fun y ->  return fun (x) -> x let x = fun (x) -> x y in x);
effect_clauses = (fun (type a) (type b) (x : (a, b) effect) ->
             ((match x with | Dummy -> (fun (_ : unit) (l : int -> _ computation) -> return fun (x) -> x fun (x1) -> fun (x2) -> fun (x) -> x x1 fun (x) -> x x2 h8 fun (x) -> x 3) | eff' -> fun arg k -> Call (eff', arg, k)) : a -> (b -> _ computation) -> _ computation)) } c in let h6 = fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> fun (x) -> x y  x1 return fun (x) -> x x2 fun c -> handler {
 value_clause = (fun y ->  return fun (x) -> x let x = fun (x) -> x y in x);
effect_clauses = (fun (type a) (type b) (x : (a, b) effect) ->
             ((match x with | Dummy -> (fun (_ : unit) (l : int -> _ computation) -> return fun (x) -> x fun (x1) -> fun (x2) -> fun (x) -> x x1 fun (x) -> x x2 h7 fun (x) -> x 3) | eff' -> fun arg k -> Call (eff', arg, k)) : a -> (b -> _ computation) -> _ computation)) } c in let h5 = fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> fun (x) -> x y  x1 return fun (x) -> x x2 fun c -> handler {
 value_clause = (fun y ->  return fun (x) -> x let x = fun (x) -> x y in x);
effect_clauses = (fun (type a) (type b) (x : (a, b) effect) ->
             ((match x with | Dummy -> (fun (_ : unit) (l : int -> _ computation) -> return fun (x) -> x fun (x1) -> fun (x2) -> fun (x) -> x x1 fun (x) -> x x2 h6 fun (x) -> x 3) | eff' -> fun arg k -> Call (eff', arg, k)) : a -> (b -> _ computation) -> _ computation)) } c in let h4 = fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> fun (x) -> x y  x1 return fun (x) -> x x2 fun c -> handler {
 value_clause = (fun y ->  return fun (x) -> x let x = fun (x) -> x y in x);
effect_clauses = (fun (type a) (type b) (x : (a, b) effect) ->
             ((match x with | Dummy -> (fun (_ : unit) (l : int -> _ computation) -> return fun (x) -> x fun (x1) -> fun (x2) -> fun (x) -> x x1 fun (x) -> x x2 h5 fun (x) -> x 3) | eff' -> fun arg k -> Call (eff', arg, k)) : a -> (b -> _ computation) -> _ computation)) } c in let h3 = fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> fun (x) -> x y  x1 return fun (x) -> x x2 fun c -> handler {
 value_clause = (fun y ->  return fun (x) -> x let x = fun (x) -> x y in x);
effect_clauses = (fun (type a) (type b) (x : (a, b) effect) ->
             ((match x with | Dummy -> (fun (_ : unit) (l : int -> _ computation) -> return fun (x) -> x fun (x1) -> fun (x2) -> fun (x) -> x x1 fun (x) -> x x2 h4 fun (x) -> x 3) | eff' -> fun arg k -> Call (eff', arg, k)) : a -> (b -> _ computation) -> _ computation)) } c in let h2 = fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> fun (x) -> x y  x1 return fun (x) -> x x2 fun c -> handler {
 value_clause = (fun y ->  return fun (x) -> x let x = fun (x) -> x y in x);
effect_clauses = (fun (type a) (type b) (x : (a, b) effect) ->
             ((match x with | Dummy -> (fun (_ : unit) (l : int -> _ computation) -> return fun (x) -> x fun (x1) -> fun (x2) -> fun (x) -> x x1 fun (x) -> x x2 h3 fun (x) -> x 3) | eff' -> fun arg k -> Call (eff', arg, k)) : a -> (b -> _ computation) -> _ computation)) } c in let h1 = fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> return fun (x) -> x y  x1 return fun (x) -> match x with | (return y) -> return fun (x) -> x y  x2 fun c -> handler {
 value_clause = (fun y ->  return fun (x) -> x let x = fun (x) -> x y in x);
effect_clauses = (fun (type a) (type b) (x : (a, b) effect) ->
             ((match x with | Dummy -> (fun (_ : unit) (l : int -> _ computation) -> return fun (x) -> x fun (x1) -> fun (x2) -> fun (x) -> x x1 fun (x) -> x x2 h2 fun (x) -> x 3) | eff' -> fun arg k -> Call (eff', arg, k)) : a -> (b -> _ computation) -> _ computation)) } c in fun (x) -> match x with | (return y) -> fun (x) -> x y  fun (x) -> match x with | (return y) -> return fun (x) -> x y  fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> return fun (x) -> x y  x1 fun (x) -> x x2 effect Dummy () fun (x1) -> fun (x2) -> fun (x) -> match x with | (return y) -> return fun (x) -> x y  x1 return fun (x) -> match x with | (return y) -> return fun (x) -> x y  x2 h1
